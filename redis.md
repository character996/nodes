# redis知识

## redis安装

>apt-get install redis

或者

下载、解压、编译Redis

```
wget http://download.redis.io/releases/redis-5.0.5.tar.gz
tar xzf redis-5.0.5.tar.gz
cd redis-5.0.5
make
```

在解压目录下启动redis
>redis-server

`redis-cli`进入客户端

## redis基础

### redis 键操作

EXISTS 查看key是否存在

DEL 删除key

TYPE 返回key对应的值的存储类型

TTL 用来查看key对应的值剩余存活时间。

EXPIRE 设置key 过期时间

PERSIST 去除过期时间

### redis数据类型

无论何种类型，在redis中都是以 key-value 的形式存在，只是 value 的类型不同。

#### 字符串

二进制安全的字符串,使用set和get来操作,值可以是任何种类的字符串

INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值,这个操作是原子性的

GETSET 将key设置为新值并返回原来的值

MSET、MGET 一次性操作多个key，操作是原子的

#### 哈希表

由field和关联的value组成的map。field和value都是字符串的,Hash 便于表示 objects

HMSET 指令设置 hash 中的多个域，而 HGET 取回单个域。HMGET 和 HGET 类似，但返回一系列值

HGETALL 返回所有的键值

#### 列表

采用的是链表存储

LPUSH 命令可向list的左边（头部）添加一个新元素

RPUSH 命令可向list的右边（尾部）添加一个新元素

取值 lrange mylist 0 -1   0 和 -1 是索引，规则与python索引相同

pop 从list中删除元素并同时返回删除的值。可以在左边 lpop 或右边 rpop 操作。

LTRIM 把 list 从左边截取指定长度。

 BRPOP 和 BLPOP 命令 阻塞式访问 list，可以在获取数据时指定如果数据不存在阻塞的时间，如果在时限内获得数据则立即返回，如果超时还没有数据则返回null, 0表示一直阻塞。

list key 添加值时自动创建，所有元素弹出后，自动销毁

#### 集合

Set 是 String 的无序排列。在每次调用时可能按照任意顺序返回元素

SADD 指令把新的元素添加到 set 中

SISMEMEBERS 确定元素是否在集合中

SMEMEBERS 返回集合所有元素

#### 有序集合

有序集合不包含相同的字符串。有序集合，可以非常快地（O(log(N))）完成添加，删除和更新元素的操作，元素是在插入时就排好序的。

每个元素关联一个浮点类型的分数，根据分数来进行排名。

元素不能重复，但是score可以重复。

ZADD 向有序集合添加一个或多个成员，或者更新已存在成员的分数

ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员(stop也包括，与列表不同)

### redis事物

一次执行多个命令

特征：

1. 是一个隔离操作，事物中的操作按顺序执行，在执行过程中，不会被其他客户端发来的请求打断。

2. 事物原子操作：事务中的命令要么全部被执行，要么全部都不执行。

用法：

MULTI 开启事物，之后所有的命令都不会立即被执行，会被放到队列中，调用 EXEC 之后，命令才会被执行。

调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务

错误处理：

1. 在 EXEC 执行前发生的错误，拒绝执行，放弃事物。

2. EXEC 之后产生的错误，即使有的语句错误，事物仍会继续执行下去，不会回滚。

WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。

WATCH key 键会被监视，事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。EXEC调用后，不管事物是否成功执行，监视都会取消。

这种形式的锁被称作乐观锁。(适合读操作比较多的数据库中)

### redis Lua脚本

EVAL 和 EVALSHA 命令是从 Redis 2.6.0 版本开始的，使用内置的 Lua 解释器，可以对 Lua 脚本进行求值。

EVAl 的第一个参数是一段 Lua 5.1 脚本程序，运行在 Redis 服务器中。第二个参数是参数的个数，后面的参数（从第三个参数），表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] )。最后是附加参数，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1]  )。

#### Lua 数据类型和 Redis 数据类型之间转换

当 Lua 通过 call() 或 pcall() 函数执行 Redis 命令的时候，命令的返回值会被转换成 Lua 数据结构。 同样地，当 Lua 脚本在 Redis 内置的解释器里运行时，Lua 脚本的返回值也会被转换成 Redis 协议(protocol)，然后由 EVAL 将值返回给客户端。

这种转换基本上一一对应的关系，需要特别注意:

1. Lua boolean true -> Redis integer reply with value of 1. / Lua 布尔值 true 转换成 Redis 整数回复中的 1

2. Lua 中整数与浮点数没有区别，要返回浮点数，需要将它作为一个字符串

3. 在Lua数组中没有nil的简单方法，这是Lua表语义的结果，因此，当Redis将Lua数组转换为Redis协议时，如果遇到nil，则停止转换

#### 脚本原子性

Redis 使用单个 Lua 解释器去运行所有脚本，Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。与事物比较相似。因此要注意的是脚本的运行速度要尽量保持快速，不然其他的客户端会因为服务器正忙不能执行命令。

#### 脚本缓存和 EVALSHA

Redis 保证所有被运行过的脚本都会被永久保存在脚本缓存当中，使用 EVALSHA 命令可以不用传递脚本给服务器，利用 SHA1 校验码在服务端找到对应的缓存脚本，然后通过传递的 key 和 arg 来运行脚本，这减少了带宽损耗。

script命令

1. SCRIPT FLUSH ：清除所有脚本缓存
2. SCRIPT EXISTS ：根据给定的脚本校验和，检查指定的脚本是否存在于脚本缓存
3. SCRIPT LOAD ：将一个脚本装入脚本缓存，但并不立即运行它
4. SCRIPT KILL ：杀死当前正在运行的脚本

### 发布/订阅模式

发布者将消息发到不同的频道，不需要知道什么样的订阅者订阅。订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的。这种发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑。

客户端订阅频道 `SUBSCRIBE foo bar`

给频道发消息   `PUBLISH` ，发送消息后会返回接收消息的客户端的数量

在客户端订阅频道后，如果频道有消息，客户端就会接收到三行消息，代表 message、频道、消息内容。

模式匹配订阅  `PSUBSCRIBE news.*`

取消订阅匹配模式 `PUNSUBSCRIBE news.*`

### master/slaver 主从复制机制

1. 使用异步复制，从服务器会以每秒一次的频率向主服务器报告复制流（replication stream）的处理进度。
2. 从服务器也可以有从服务器,一个主服务器可以有多个从服务器
3. 复制功能不会阻塞主服务器和从服务器，但是 在从服务器删除旧版本数据集并载入新版本数据集的那段时间内， 连接请求会被阻塞。

4. 主服务器可以让从服务器执行持久化功能，自己不执行。但是主服务器关闭持久化时，要避免自动拉起，因为主服务器崩溃之后自动拉起后没有数据，从服务器从主服务器复制数据，会使自己保存的数据也清空。

#### 配置

##### 从服务器

绑定主服务器的 ip 和端口

在配置文件中永久保存
>slaveof 192.168.1.1 6379

在客户端中一次连接
>slaveof 192.168.1.1 6379

密码连接

客户端中输入 `config set masterauth <password>`

配置文件中 `masterauth <password>`

只读配置,配置文件中  `slave-read-only yes` ，这是默认配置

##### 主服务器

网络延迟的最大值 min-slaves-max-lag （默认 10）

执行写操作所需的至少从服务器数量 min-slaves-to-write （默认 0）

#### 部分重同步

在网络连接短暂性失效之后，重新连接之后，主从服务器可以尝试继续执行原有的复制进程（process）， 而不一定要执行完整重同步操作。

实现：需要主服务器为被发送的复制流创建一个内存缓冲区（in-memory backlog）， 并且主服务器和所有从服务器之间都记录一个复制偏移量（replication offset）和一个主服务器 ID （master run id）， 当出现网络连接断开时， 从服务器会重新连接， 并且向主服务器请求继续执行原来的复制进程。

### 持久化

#### RDB 持久化

指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。

RDB 适合备份和数据恢复，由子进程的方式保存数据，最大化发挥 redis 性能。

但是它会丢失一些数据，并且在数据量非常巨大时 fork 子进程会对服务器产生影响。

#### AOF 持久化

记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。

AOF 可执行不同的 fsync 策略，可以保持良好性能。是一个只进行追加操作的文件，可以在文件体积过大时重写文件，重写时会继续追加命令，重写完成后从旧文件转到新文件。AOF较容易读懂。

缺点是文件体积较大，速度比 RDB 慢，存储的命令在重新载入时可能会出现 bug

#### 持久化配置

redis 默认使用 RDB 持久化，将数据库快照保存在名字为 dump.rdb 的二进制文件中。可以设置 RDB 存储的快照频率。比如 `save 60 1000` 会让 Redis 在“ 60 秒内有至少有 1000 个键被改动 ”时保存数据。将save 注释关闭 RDB 持久化。

打开 AOF 持久化，配置文件中将 `appendonly` 设置为 yes 。

启动时，如果 RDB 和 AOF 都被打开了，那么启动时会优先使用 AOF 文件恢复数据。